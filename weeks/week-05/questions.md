1. В чем главное концептуальное отличие GraphQL от REST?

Главное отличие в том, что в GraphQL клиент сам указывает, какие данные ему нужны, а в REST сервер возвращает фиксированный набор данных.

В REST существует множество эндпоинтов, и каждый возвращает заранее определенную структуру.

В GraphQL существует один эндпоинт, и клиент отправляет запрос, в котором явно указывает нужные поля. Сервер возвращает только эти данные, без лишней информации.

Это решает проблемы:  
Overfetching - получение лишних данных;  
Underfetching - необходимость делать несколько запросов.

2. Что такое Schema Definition Language (SDL)?

Schema Definition Language (SDL) - это язык описания схемы GraphQL.

Он используется для определения:  
типов данных (type);
запросов (Query);  
мутаций (Mutation);  
входных данных (input).

SDL является контрактом между клиентом и сервером.

3. Чем Query отличается от Mutation? Могут ли они выполняться параллельно?

Query используется для чтения данных, а Mutation - для изменения данных.

Аналогия с REST:  
Query схожа с GET;  
Mutation схожа с POST/PUT/DELETE.

Query могут выполняться параллельно, потому что они не изменяют данные.  
Mutation выполняются последовательно, чтобы избежать конфликтов и обеспечить согласованность данных.

4. Что такое резолвер (resolver) и кто его вызывает?

Резолвер - это функция на сервере, которая возвращает данные для конкретного поля, запроса или мутации.

Он отвечает за получение данных, например:  
из базы данных;  
из файла;  
из API;  
из памяти.

Резолвер автоматически вызывается GraphQL сервером, когда клиент запрашивает соответствующее поле.

5. Как решается проблема N+1 запросов в GraphQL (dataloader)?

Проблема N+1 возникает, когда для получения списка объектов выполняется один запрос, а затем для каждого объекта выполняется дополнительный запрос.

DataLoader решает эту проблему путем:  
группировки (batching) нескольких запросов в один;  
кэширования результатов.

Вместо 100 отдельных запросов к базе данных выполняется один общий запрос, это уменьшает нагрузку на базу данных и ускоряет выполнение.

6. Почему в GraphQL сложно реализовать кэширование на уровне HTTP (как в REST)?

В REST каждый URL соответствует конкретному ресурсу, поэтому его легко кэшировать.

В GraphQL все запросы отправляются на один URL, но содержимое запроса может быть разным.

Стандартное HTTP-кэширование неэффективно, и GraphQL обычно использует:  
кэширование на уровне клиента;  
кэширование на уровне резолверов;  
DataLoader.

