1. Зачем нужны variables в GraphQL запросе? Почему нельзя просто склеивать строки?

Variables позволяют передавать значения в запрос отдельно от текста запроса.
Причины, почему нельзя просто склеивать строки:
	безопасность — предотвращает GraphQL-инъекции;
	производительность — сервер может кешировать структуру запроса;
	удобство — можно менять значения без изменения текста запроса;
	правильная архитектура GraphQL.

Variables — это аналог prepared statements в SQL.

2. Из каких полей состоит стандартный JSON-запрос к GraphQL серверу?

Основные поля:
	query — текст GraphQL запроса или mutation;
	variables — словарь переменных.

Дополнительно может быть:
	operationName — имя операции.

3. Почему у GraphQL обычно только один URL endpoint?

В отличие от REST, GraphQL использует один endpoint, так как это позволяет клиенту самому выбирать:
	какие данные получить;
	какие поля нужны;
	какую операцию выполнить.

Это упрощает архитектуру и делает API гибким.

4. Что означает наличие поля errors в ответе сервера? Может ли оно прийти вместе с data?

Поле errors означает, что произошла ошибка выполнения GraphQL запроса.
Возможны три варианта:

Полный успех:

	{
	  "data": { ... }
	}

Частичный успех:

	{
	  "data": { ... },
	  "errors": [ ... ]
	}

	Часть данных получена, часть — с ошибкой.

Полная ошибка:

	{
	  "errors": [ ... ]
	}

	data отсутствует.

5. Как клиент должен обрабатывать ошибки, если HTTP статус ответа 200?

В GraphQL HTTP статус 200 не означает отсутствие ошибок.
Нужно обязательно проверять поле:

	response = requests.post(...)
	result = response.json()

	if "errors" in result:
	    print("Ошибки:", result["errors"])

	if "data" in result:
	    print("Данные:", result["data"])

GraphQL возвращает ошибки внутри JSON, а не через HTTP статус.

6. В чем плюсы типизированных клиентов (Apollo Client, Relay) перед простыми HTTP-запросами?

Преимущества:
	1. Автодополнение и проверка типов
		Ошибки обнаруживаются ещё на этапе разработки;
	2. Кеширование
		Клиент автоматически кеширует данные и уменьшает количество запросов;
	3. Удобство работы
		Не нужно вручную писать requests.post;
	4. Управление состоянием
		Автоматическое обновление данных в интерфейсе;
	5. Безопасность типов
		Типы строго соответствуют GraphQL схеме;
	6. Упрощение разработки больших проектов
		Меньше ошибок и меньше ручного кода;

